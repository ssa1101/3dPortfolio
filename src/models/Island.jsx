/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: Animateria (https://sketchfab.com/Animateria)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/volcano-island-lowpoly-4a6591dc9fee40d8bfda8350683af9af
Title: Volcano Island Lowpoly
*/

import React, { useRef , useEffect} from 'react'
import { useGLTF } from '@react-three/drei'
import {useFrame, useThree} from '@react-three/fiber'
import islandScene from '../assets/3d/volcano_island_lowpoly.glb'
import { a} from "@react-spring/three"
const Island = ({isRotating, setIsRotating, setCurrentStage, ...props}) => {
  const islandRef = useRef();
  const {gl, viewport} = useThree();
  const { nodes, materials } = useGLTF(islandScene);
  const lastX = useRef(0);
  const rotationSpeed = useRef(0);
  const dampingFactor = 0.95;

  const handlePointerDown = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(true);
    // determine if event touch is mobile or desktop
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    // store last position
    lastX.current = clientX;
  }
  const handlePointerUp = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(false);
  

  }
  const handlePointerMove = (e) => {
    e.stopPropagation();
    e.preventDefault();

    if (isRotating) {
        // calc change in horiz position
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    // store last position
    const delta = (clientX - lastX.current) / viewport.width;
    //update isl rotation based on mouse
    islandRef.current.rotation.z += delta * 0.01 * Math.PI ;
    lastX.current = clientX;
    rotationSpeed.current = delta * 0.01 * Math.PI;
    }
   
  }
  const handleKeyDown = (e) => {
    if (e.key === 'ArrowLeft'){
        if (!isRotating) setIsRotating(true);
        islandRef.current.rotation.z += 0.01 * Math.PI;
        rotationSpeed.current = 0.0125;
    } else if (e.key === 'ArrowRight'){
        if (!isRotating) setIsRotating(true);
        islandRef.current.rotation.z -= 0.01 * Math.PI;
        rotationSpeed.current = -0.0125;
    }
   
  }
  const handleKeyUp = (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight'){
        setIsRotating(false);
    }
  }
  //applies to every frame 
  useFrame(()=>{
    if(!isRotating){
        rotationSpeed.current *= dampingFactor;

        if(Math.abs(rotationSpeed.current) < 0.001){
            rotationSpeed.current = 0;
        }
        islandRef.current.rotation.z += rotationSpeed.current;
    }else {
        const rotation = islandRef.current.rotation.z;
         /**
       * Normalize the rotation value to ensure it stays within the range [0, 2 * Math.PI].
       * The goal is to ensure that the rotation value remains within a specific range to
       * prevent potential issues with very large or negative rotation values.
       *  1. rotation % (2 * Math.PI) calculates the remainder of the rotation value when divided
       *     by 2 * Math.PI. This essentially wraps the rotation value around once it reaches a
       *     full circle (360 degrees) so that it stays within the range of 0 to 2 * Math.PI.
       *  2. (rotation % (2 * Math.PI)) + 2 * Math.PI adds 2 * Math.PI to the result from step 1.
       *     This is done to ensure that the value remains positive and within the range of
       *     0 to 2 * Math.PI even if it was negative after the modulo operation in step 1.
       *  3. Finally, ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI) applies another
       *     modulo operation to the value obtained in step 2. This step guarantees that the value
       *     always stays within the range of 0 to 2 * Math.PI, which is equivalent to a full
       *     circle in radians.
       */
      const normalizedRotation =
      ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
 
      // console.log(normalizedRotation)
    //   console.log(normalizedRotation);
    // Set the current stage based on the island's orientation
    // console.log(normalizedRotation);
    switch (true) {
    //   case normalizedRotation >= 5.45 && normalizedRotation <= 5.85:
    //     setCurrentStage(4); // start at stage 0, diff stages for diff prompts
    //     break;
    //   case normalizedRotation >= 0.85 && normalizedRotation <= 1.3:
    //     setCurrentStage(3);
    //     break;
    //   case normalizedRotation >= 2.4 && normalizedRotation <= 2.6:
    //     setCurrentStage(2);
    //     break;
    //   case normalizedRotation >= 4.25 && normalizedRotation <= 4.75:
    //     setCurrentStage(1);
    //     break;
    //   default:
    //     setCurrentStage(null);
    
    // case normalizedRotation < 3.5 && normalizedRotation > 0.8:
    //     setCurrentStage(4); // start at stage 0, diff stages for diff prompts
    //     break;
      case normalizedRotation >= 3.5 && normalizedRotation < 5.99:
        setCurrentStage(4);
        break;
      case normalizedRotation >= 5.99 || normalizedRotation < 0.38:
        setCurrentStage(2);
        break;
      case normalizedRotation <= 0.8 && normalizedRotation >=0.38:
        setCurrentStage(1);
      case normalizedRotation <= 3 && normalizedRotation >=0.8:
          setCurrentStage(3);
        break;
      default:
        setCurrentStage(null);
    }
    }
  })
  useEffect(()=>{
    const canvas = gl.domElement; // have to attach elements to canvas, not just regular dom
    canvas.addEventListener('pointerdown', handlePointerDown);
    canvas.addEventListener('pointerup', handlePointerUp);
    canvas.addEventListener('pointermove', handlePointerMove);
    document.addEventListener('keydown', handleKeyDown);
 
    document.addEventListener('keyup', handleKeyUp);

    return () =>{
        canvas.removeEventListener('pointerdown', handlePointerDown);
        canvas.removeEventListener('pointerup', handlePointerUp);
        canvas.removeEventListener('pointermove', handlePointerMove);
        document.removeEventListener('keydown', handleKeyDown);
         document.removeEventListener('keyup', handleKeyUp);
    }
  },[gl, handlePointerDown, handlePointerMove, handlePointerUp])
  return (
    <a.group ref={islandRef}{...props} >
      <mesh
        geometry={nodes.Clouds_Clouds_0.geometry}
        material={materials.Clouds}
        // rotation={[-Math.PI / 2, 0, 0]}
        // scale={100}
      />
      <mesh
        geometry={nodes.hammock_hammock_0.geometry}
        material={materials.hammock}
        // position={[180.509, 1151.676, 5904.325]}
        // rotation={[-Math.PI / 2, 0, 0]}
        // scale={100}
      />
      <mesh
        geometry={nodes.Tequila_Bottle_Tequila_Bottle_0.geometry}
        material={materials.Tequila_Bottle}
        // position={[3492.547, 1112.371, 3620.925]}
        // rotation={[-1.38, 0.112, -0.022]}
        // scale={100}
      />
      <mesh
        
        geometry={nodes.skeleton_skeleton_0.geometry}
        material={materials.skeleton}
        // position={[3541.67, 1110.094, 3568.021]}
        // rotation={[-Math.PI / 2, 0, 0]}
        // scale={100}
      />
      <mesh
        geometry={nodes.Pyramid_Pyramid_0.geometry}
        material={materials.Pyramid}
        // rotation={[-Math.PI / 2, 0, 0]}
        // scale={100}
      />
      <mesh
        geometry={nodes.Island_Grass_Island_Grass_0.geometry}
        material={materials.Island_Grass}
        // rotation={[-Math.PI / 2, 0, 0]}
        // scale={100.041}
      />
      <mesh
        geometry={nodes.shrubbery_shrubbery_0.geometry}
        material={materials.shrubbery}
        // rotation={[-Math.PI / 2, 0, 0]}
        // scale={100}
      />
      <mesh
        // castShadow
        // receiveShadow
        geometry={nodes.Lava_bubble_Lava_bubble_0.geometry}
        material={materials.Lava_bubble}
        // rotation={[-Math.PI / 2, 0, 0]}
        // scale={100}
      />
      <mesh
        // castShadow
        // receiveShadow
        geometry={nodes.Volcanic_lava_Volcanic_lava_0.geometry}
        material={materials.Volcanic_lava}
        // rotation={[-Math.PI / 2, 0, 0]}
        // scale={100}
      />
      <mesh
        geometry={nodes.Palm_tree_2_Palm_tree_2_0.geometry}
        material={materials.Palm_tree_2}
        // rotation={[-Math.PI / 2, 0, 0]}
        // scale={100}
      />
      <mesh
        geometry={nodes.Palm_tree_1_Palm_tree_1_0.geometry}
        material={materials.Palm_tree_1}
        // rotation={[-Math.PI / 2, 0, 0]}
        // scale={100}
      />
      <mesh
        geometry={nodes.Volacano_Sand_Volacano_Sand_0.geometry}
        material={materials.Volacano_Sand}
        // rotation={[-Math.PI / 2, 0, 0]}
        // scale={100}
      />
      <mesh
        geometry={nodes.Ocean_Ocean_0.geometry}
        material={materials.Ocean}
        // rotation={[-Math.PI / 2, 0, 0]}
        // scale={100}
      />
      <mesh
        geometry={nodes.Volcano_Grass_Volcano_Grass_0.geometry}
        material={materials.Volcano_Grass}
        // rotation={[-Math.PI / 2, 0, 0]}
        // scale={100}
      />
      <mesh
        geometry={nodes.Volcano_Base_Volcano_Base_0.geometry}
        material={materials.Volcano_Base}
        // rotation={[-Math.PI / 2, 0, 0]}
        // scale={100.041}
      />
    </a.group>
  )
}

// useGLTF.preload('/volcano_island_lowpoly.glb')
export default Island;